# Отчет к лабораторной работе 2: Динамическая маршрутизация с использованием протокола ISIS

## Задание к лабораторной работе:

### 1.Разобраться с CLI по настройке протокола ISIS на всех устройствах (контейнерах) согласно прилагаемой схеме (используется топология из Лабораторной работы 1) и примеру в Приложении
Разобрался с CLI FRR 
### 1.1 Была IP-связность с lo (loopback) интерфейса R1 до lo интерфейсов R2 и R3 (аналогично от lo R2 до lo R1 и R3, от lo R3 до lo R1 и R2)
Связность имеется 
### 1.2 Была IP-связность между всеми РС, объяснить почему используется этот маршрут (2-3 предложения и подтверждающий вывод с маршрутизатора).
Связность между всеми PC присутствует.  
Рассмотрим вывод команды `traceroute` для узла `PC1` к адресу `192.168.22.4` (`eth1` для `PC2`):  
```
PC1# traceroute 192.168.22.4
traceroute to 192.168.22.4 (192.168.22.4), 30 hops max, 46 byte packets
 1  192.168.11.1 (192.168.11.1)  0.004 ms  0.005 ms  0.004 ms
 2  192.168.1.2 (192.168.1.2)  0.002 ms  0.003 ms  0.002 ms
 3  192.168.22.4 (192.168.22.4)  0.002 ms  0.003 ms  0.002 ms
PC1# 
```
Как мы видим, маршрут фактически является кратчайшим.  
Любую сетевую топологию можно представить в виде графа, где вершины – это узлы сети, а ребра – маршруты между ними. При использовании динамической маршрутизации, граф как правило будет иметь большую связность чем при статической маршрутизации. Достигается это за счет того, что при динамической маршрутизации протоколом поддерживаются всевозможные маршруты между двумя узлами. При этом выбирается  маршрут с меньшей метрикой (более короткий), что мы и наблюдаем в данном случае.

###  1.3 Разорвать (логически) линк между R1 и R2, проверить есть ли связность между РС1 и РС2, объясните полученный результат.
Линк разорван, связность, в отличие от статической маршрутизации, сохранилась. Как уже было написано выше, при динамической маршрутизации протоколом поддерживаются всевозможные маршруты между двумя узлами. Сооответственно, если в случае разрыва линка один маршрут перестал существовать, но альтернативы есть, то будет выбран один из этих оставшихся маршрутов. Выбор нового маршрута при этом также будет сделан на основании метрик маршрутов в таблице маршрутизации.   
Это мы и можем наблюдать при выполнении команды `traceroute` для узла `PC1` к адресу `192.168.22.4` (`eth1` для `PC2`) с разорванной связью между `PC1` и `PC2` через интерфейс `eth1`
```
PC1# traceroute 192.168.22.4
traceroute to 192.168.22.4 (192.168.22.4), 30 hops max, 46 byte packets
 1  192.168.11.1 (192.168.11.1)  0.005 ms  0.004 ms  0.006 ms
 2  192.168.2.3 (192.168.2.3)  0.002 ms  0.004 ms  0.002 ms
 3  192.168.3.2 (192.168.3.2)  0.002 ms  0.004 ms  0.002 ms
 4  192.168.22.4 (192.168.22.4)  0.002 ms  0.004 ms  0.002 ms
```

### 1.4 Дополнительное задание: Удалить на R1, на интерфейсе eth1 команду isis network point-to-point, объяснить в нескольких предложениях получившийся результат с приведением подтверждающих show команд с маршрутизатора.
В ISIS доступно два вида сети: `broadcast` и `point-to-point`. В моем понимании тип сети `point-to-point` – это сетевое взаимодействие между двумя узлами непосредственно, любая связь между ними никак не может затронуть другие узлы сети. В свою очередь `broadcast` тип сети является широковещательным. То есть, если мы попытаемся пингануть широковещательный адрес, ответ будет получен от всех доступных узлов сети.   
Однако, если я убираю тип сети `isis network point-to-point` для интерфейса `eth1` роутера `R1`, никаких видимых изменений не наблюдается.  
Несколько предположений почему так происходит:
1) Тип сети `point-to-point` используется в ISIS по умолчанию;
2) Т. к. все узлы сети имеют тип сети `point-to-point`, то эффект широковещательного вещания не ощутим;
3) Я что-то сделал неправильно : ) 


### 2 Написать генератор конфигурации ISIS для остальных PC и R маршрутизаторов на Python (не забыть, что в нем нужна также и базовая конфигурация - IP-адреса итд.)
Генератор конфигурации реализован в файле: `src/tsk2/conf_generator.py`  
**Предварительные требования**:  
Необходимо, чтобы были произведены базовые настройки окружения. То есть все контейнеры топологии должны быть подняты и активны.  
**Инструкция**:  
Скрипт сам подключается к необходимым узлам топологии (контейнерам) и выполняет необходимые команды.   
При этом все исполняыемые команды записываются в соответствующие `.conf` файлы.  
Для каждого устройства – свой файл. В качестве примеры файлы так же приложены, находятся по пути:
`src/tsk2/artifacts/**`
### 3 Написать скрипт на Python, делающий парсинг вывода
Генератор конфигурации реализован в файле: `src/tsk3/parse_node_commands.py`.  
В файл `output.txt` записываются все исполняемые команды, а так же их результат.  
В файле `output_with_link_R1_R2.txt` представлен вывод команд с имеющейся связью между роутерома `R1` и `R2`.  
В файле `output_without_link_R1_R2.txt` представлен вывод команд, соответственно, без связи между `R1` и `R2`.
Пример файла находится по пути: `src/tsk3/artifacts/output.txt`
